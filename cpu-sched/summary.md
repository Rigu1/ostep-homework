 ## 스케일줄링 정책
- 스케줄링 정책을 생각하기 위한 기본적인 프레임워크를 어떻게 민들어야 하는가?
- 핵심 과정은 무엇인가?
- 어떤 평가 기준이 중요한가?
- 컴퓨터 시스템 초창기 사용된 기본 접근법은 무엇인가?

## 워크로드에 대한 가정
- 워크로드란
    - 일련의 프로세스들이 실행하는 상황

현재 상황에 대한 가정은 다음과 같다.
1. 모든 작업은 같은 시간 동안 실행된다.
2. 모든 작업은 동시에 도착한다.
3. 각 작업은 시작되면 완료될 때까지 실행된다.
4. 모든 작업은 CPU만 사용한다.
5. 각 작업의 실행 시간은 사전에 알려져있다.

## 스케줄링 평가 항목
- 반환 시간
    - 작업이 완료된 시각 - 작업이 시스템에 도착한 시간
    - 성능 측면에서의 평가 기준

## 가장 기초적인 스케줄링 FIFO
가장 기초직인 스케줄링은 선입선출이다. (FCFS 스케줄링)
이 단순한 스케줄링은 다음과 같은 장점을 가진다.
- 단순하고 구현하기 쉽다.
- 현 가정에서 잘 작동한다.

### 작업의 실행속도가 모두 같지 않다면
A, B, C의 순으로 실행될 때 A의 실행 속도가 100초이고 나머지가 10초라면 시스템의 평균 반환 속도는 110초다.
- 이런 문제는 `convoy effect`라 하며 짧은 시간 자원을 사용할 프로세스들이 자원을 오랫동안 사용하는 프로세의 종료를 기다리는 현상을 말한다.

#### 최단 작업 우선(SJF)
이러한 문제를 해결하는 방법은 간단히 짧은 실행 시간을 가진 작업을 먼저 실행시키는 것이다.  
이 원칙을 스케줄 해보면 위 A, B, C의 프로세스를 순차적으로 실행하는 것이 아닌 B, C를 실행한 다음 A를 실행하게 되면 평균 반환 속도는 50초로 2배 이상 향상된 결과를 얻을 수 있다.
- 모든 작업이 동시에 도착한다는 전제 하에는 SJF가 최적의 스케줄링 알고리즘을 증명할 수 있다.

### 모든 작업이 동시에 도착하지 않는다면
100초의 실행 시간을 가진 A는 t = 0, 10초의 실행 시간을 가진 B, C는 t = 10에 도착한다 가정하자. 이를 SJF로 스케줄했을 경우 `convoy effect`가 다시 발생하게 된다. 
- 이 문제의 해결을 위해서는 A 작업을 중지하고 B, C를 실행하도록 설정해야 한다.
    - `각 작업은 시작되면 완료될 때까지 실행된다.`라는 제약도 이 시점에 완화한다.
- SJF는 비선점형 스케줄러이기에 이 문제를 해결할 수 없다.

#### 최단 잔여시간 우선(STCF)
이 스케줄러는 남아있는 작업과 새로운 작업의 잔여 실행 시간을 계산하고 그 중 가장 적은 실행 시간을 가진 작업을 스케줄링한다.

이를 통해 위 A, B, C의 평균 반환 시간이 다시 50초로 줄어든다.
- 현 가정 내에서는 STCF가 최적의 스케줄링이 된다.

### 새로운 평가 항목 - 응답 시간
현재 완화된 기준들
1. 작업의 길이를 미리 알고 있다.
2. 작업이 오직 CPU만 사용한다.
에서는 STCF는 매우 훌륭한 정책이다.
- 초기 일괄처리 컴퓨터 시스템에서는 이 알고리즘이 의미가 있었다.
- 이후 시분할 컴퓨터의 등장으로 터미널에서 작업하며 시스템에게 상호작용을 원할히 하기 위한 성능을 요구하게 됨에 따라 `응답시간` 이라는 새로운 평가 기준이 등장한다.

응답 시간은 작업이 도착할 떄부터 처음 스케줄 될 떄까지의 시간으로 정의된다.
- 작업이 도착힌 시각 - 스케줄 된 시각

#### 기존 정책의 한계
기존 STCF 정책을 보면 응답 시간이 짧다고 할 수 없다. 
- 반환 시간 기준으로는 훌룡한 반면 다른 작업이 먼저 스케줄된 경우에 응답 시간과 상호작용 부분에서 매우 부적절하다.

### 라운드 로빈
이 응답 시간 문제를 해결하기 위해 `라운드 로빈` 스케줄링 알고리즘이 도입되었다.  
기본 발상은 작업이 끝낧 떄 까지 기다리는 것이 아닌 일정 시간 실행한 뒤 실행 큐의 다음 작업으로 전환하는 방법이다. 
- 이때 작업이 실행되는 시간을 `타임 슬라이스` 혹은 `스메줄링 퀸텀`이라 부른다.
- 타임 슬라이스의 길이는 인터럽트 주기의 배수여야 한다.

- 3개의 작업 A, B, C가 시스템에 동시에 도착하고, 각각 5초간 실행된다고 가정하자.
    - 1초의 타임 슬라이스를 가지는 라우터 로빈의 경우 평균 응답 시간은 1초다.
    - SJF의 경우 평균 응답 시간은 5초다.

#### 상쇄
> 비용의 상쇄
일반적인 상쇄는 특정 연산에 고정 비용이 존재하는 시스템에서 흔히 사용되며 그 비용이 적은 횟수로 발생하게 하여 시스템의 전체 비용을 감소시킨다.
예를 들어 타임 슬라이스는 10초, 교환 비용이 1초라면 10%의 시간이 문맥 교환에 사용되어 낭비되지만 이 비용을 상쇄하려는 경우 타임 슬라이스를 100초로 늘려 1% 미만의 시간이 문맥 교환에 소모되도록 상쇄시킬 수 있다.

타임 슬라이스가 짧을수록 응답 시간 기준으로 라우터 로빈의 성능은 좋아지지만 너무 짧으면 문맥 교환 비용이 전체 성능에 큰 영향을 주게된다.
- 문맥 교환의 비용을 상쇄할 수 있을 만큼 길어야 하지만 응답 시간이 너무 길어지면 안된다.

- 문맥 교환 비용에는 레지스터를 저장/복원하는 작업 외에도 CPU 캐시, TLB, 분기 예측 등 다른 하드웨어도 프로그램과 관련된 다양한 작업 정보가 저장되어 있다. 
- 작업이 전환되면 이는 모두 갱신되어야 하기에 갱신 작업이 매우 큰 비용을 유발한다.

#### 반환 시간 기준으로
적당한 길이의 응답 시간이 유일한 평가 기준인 경우 라운드 로빈은 훌룡한 스케줄러지만 반환 시간 기준으로는 적절하지 못하다.
- A, B, C가 5초간 실행되고 동시에 도착한다 할 때 라운드 로빈이 1초의 타임 슬라이스를 가진다면 평균 14의 반환 시간을 보인다.
- 라운드 로빈은 반환 시간 평가 기준에서 성능이 나쁘다.

### 입출력 연산도 고려한다면 (중첩)
이제 `모든 작업은 CPU만 사용한다.`이라는 가정을 버린다.
모든 프로그램은 입출력 작업을 수행한다.
- 입출력 작업이 요쳥된 경우 스케줄러는 다음에 어떤 작업을 실행할지를 결정해야 한다.
    - 현재 실핼 중인 작업은 입출력이 완료될 때까지 CPU를 사용하지 않을 것이기 떄문이다.
- 입출력 요청을 발생시킨 작업은 입출력 완료를 기다리며 대기 상태가 된다.
    - 스케줄러는 그 시간 동안 실행될 다른 작업을 스케줄해야 한다.
- 스케줄러는 입출력 완료 시에도 의사 결정을 해야한다.
    - 입출력이 완료되면 인터럽트가 발생하고 운영체제가 실행되어 입출력을 요청한 프로세스를 대기에서 준비 상태로 다시 이동시키거나 즉시 실행시키로 결정할 수 있다.

#### 
A와 B작업은 각각 50초의 CPU 시간을 필요로하며 A는 10초 동안 실행된 후 입출력 요청을 하며 이 작업에 10초가 걸린다. 스케줄러가 A를 실행시키고 B를 실행시킨다고 가정하자.

STCF 스케줄러를 구축하려할 때 A가 10초 작업으로 분할되고 B는 50초의 CPU를 요구한다.
- 일반적으로는 A의 각 10초 하위 작업을 독립적인 작업으로 다루는 것이다.
- 실행 시간이 짧은 10초의 A작업이 선행되고 이후 입출력 요청을 수행할 때 50초의 CPU작업이 스케줄러에 의해 스케줄링되어 작업되고 이후 입출력이 끝나고 다시 A 요청이 들어오면 다시 A요청이 처리되게 된다.
    - 프로세스의 입출력이 끝나기를 기다리는 동안 CPU는 다른 프로세스에 의해 사용되어 연산의 중첩이 가능해진다.

- 스케줄러는 cpu버스트를 하나의 작업으로 간주함으로써 대화형 프로세서가 유리하게 실행되는 것을 보장한다.

### No More Oracle
마지막 가정은 `스케줄러가 각 작업의 실행 시간을 알고 있다는 가정`으로 범용 운영체제에서 이 가정은 불가능하다.